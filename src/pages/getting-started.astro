---
import DefaultLayout from "../layouts/default.astro";
import PermaTitle from "../components/permatitle.astro";
import Code from "../components/code.astro";

const CODE: Record<string, string> = {};

CODE["counter.store.ts"] = `// @filename: counter.store.ts
// ---cut---
import { Exome } from "exome"

// We'll have a store called "CounterStore"
export class CounterStore extends Exome {
  // Set up one property "count" with default value \`0\`
  public count = 0

  // Create two actions that will update "count" value
  public increment() {
    this.count += 1
  }

  public decrement() {
    this.count -= 1
  }
}`;

CODE["index.ts"] = `// @filename: index.ts
// ---cut---
import { CounterStore } from "./counter.store.ts"

// Initialize new counter store
const counterStore = new CounterStore()

// It contains default values
counterStore.count // => 0

// We can call actions and use this instance as usual
counterStore.increment()

counterStore.count // => 1`;

CODE["index.tsx"] = `// @filename: index.tsx
// @jsx: preserve
// @jsxImportSource: react
// ---cut---
import { useStore } from "exome/react"
import { createRoot } from "react-dom/client";

import { CounterStore } from "./counter.store.ts"

const counterStore = new CounterStore()

function App() {
  // \`useStore\` will update component on action calls
  const { count, increment, decrement } = useStore(counterStore);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={decrement}>-</button>
      <button onClick={increment}>+</button>
    </div>
  );
}

createRoot(document.body).render(<App />);`;
---

<DefaultLayout>
	<h1 id="getting-started">Getting Started</h1>

	<PermaTitle title="Install Exome" />

	<p>
		First things first, download and install <code
			><a href="" target="_blank" referrerpolicy="no-referrer">exome</a></code
		> pacakge. It can be installed using npm.
	</p>

	<p>
		<pre>npm install exome</pre>
	</p>

	<PermaTitle title="Your first store" />

	<p>
		To create a new store, just build a new class and extend it from `Exome`.
		This will make all the necessary setup for state to be listen for actions.
	</p>

	<p>
		For example lets create a new counter store, that will have two synchronous
		actions `increment` and `decrement` that will change value for `count`
		property.
	</p>

	<div class="note">
		<p>There are a few recommendations on how to organize stores:</p>

		<p>
			<ul>
				<li>keep each store in a separate file to minimize file sizes;</li>
				<li>
					name files with <code>*.store.ts</code> extension to easily find store
					files;
				</li>
				<li>
					name stores in PascalCase ending with <code>*Store</code> to better distinguish
					them from components;
				</li>
			</ul>
		</p>

		<p>
			Note that these are only recommendations and nothing is forced! You can
			chose to ignore them.
		</p>
	</div>

	<p>
		Lets create a new store file <code>counter.store.ts</code> and fill it with our
		first store:
	</p>

	<Code
		lang="ts"
		code={`// @noErrors
${CODE["counter.store.ts"]}
`.trim()}
	/>

	<p>
		Now that we have this first store, we can initialize it just like any other
		class to use it. We can do it in the same file if it's single global store
		where a lot of different parts need to access it. But if we expect there to
		be many counters, we can do it wherever we need it.
	</p>

	<p>
		In this case we want many counters so lets initialize one of them in <code
			>index.ts</code
		>.
	</p>

	<Code
		lang="ts"
		code={`// @noErrors
${CODE["counter.store.ts"].replace(/\/\/ ---cut---/, "")}
${CODE["index.ts"]}
`.trim()}
	/>

	<p>
		For now this is not the impressive, currently there's nothing that listens
		to changes in that instance. So lets do that now using react integration.
		We'll use jsx in this example so we need to rename <code>index.ts</code> file
		to <code>index.tsx</code>.
	</p>

	<Code
		lang="tsx"
		code={`// @noErrors
${CODE["counter.store.ts"].replace(/\/\/ ---cut---/, "")}
${CODE["index.tsx"]}
`.trim()}
	/>

	<p>
		Actions don't have to be called in the same component to trigger updates.
		For example adding this outside the component will update it too:
	</p>

	<Code
		lang="tsx"
		code={`// @noErrors
${CODE["counter.store.ts"].replace(/\/\/ ---cut---/, "")}
const counterStore = new CounterStore()
// ---cut---
setInterval(counterStore.increment, 1000);
`.trim()}
	/>

	<p>
		<a
			href="https://dune.land/dune/468e79c1-e31b-4035-bc19-b03dfa363060"
			target="_blank"
			referrerpolicy="no-referrer">Live Preview</a
		>
	</p>

	<p>And there you have it, your first basic store.</p>

	<div class="note">
		<p>
			There's way more that can be achieved with exome, but this is bare minimum
			example of what's possible. For example store instance can contain other
			store instances in as big of a depth as necessary.
		</p>
		<p>
			Use exome with any UI framework. Even share state between them at the same
			time. Or use it as a event listener in vanilla or canvas land.
		</p>

		<p>
			<a
				href="https://codesandbox.io/p/sandbox/vue-exome-lchcp"
				target="_blank"
				referrerpolicy="no-referrer">Live Preview</a
			>
		</p>
	</div>
</DefaultLayout>
