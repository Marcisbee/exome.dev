import { LiveGuidesTodoReact } from "../components/live/guides-todo";
import { LiveGuidesIntegrationReact } from "../components/live/guides-integration";

# Guides

## Folder structure
There are no rules on how to structure stores, but working with exome for couple of years now across multiple very large projects I can make some suggestions:

1. Try to make 1 file per store;
2. Try to name store files ending with `*.store.ts`, `*.store.js`;

```txt
user.store.ts
user-list.store.ts
```

3. Try to name stores ending with `*Store`;
    - It's easy to confuse store names with component names later.

```ts
class UserStore extends Exome {}
class UserListStore extends Exome {}
```

4. Try to base all logic inside actions instead of components;
    - It's way easier to manage data flow via actions while UI frameworks only display data, UI and trigger user events.
5. If you're going with `features` folder structure, then put store there too:

```txt
my-project/
├── features/
│   └── jsonlogic-editor/
│       ├── jsonlogic-editor.component.tsx
│       └── jsonlogic-editor.store.ts
│   ...
```

6. If you're have different folder structure, then put stores together:

```txt
my-project/
├── components/
│   ...
├── stores/
│   ├── settings.store.ts
│   └── user.store.ts
│   ...
```

Now you may not follow these suggestions and maybe find some better way to handle things, might as well [open issue](https://github.com/Marcisbee/exome/issues) revealing that info with everyone.

## Nested stores
{/* @TODO use different example so that it doesn't double todo app */}
Exome is made to handle deeply nested stores with ease.

Before exome there is usually one single store, that contains everything and any mutation to it, requires data to be repeater-drilled. But not in exome.

Think of exome as atomic store. You can have as many stores as needed that each work just for themselves.

Lets start with simple todo example. First we need store that handles single todo:

```ts twoslash [todo.store.ts]
import { Exome } from "exome";

export class TodoStore extends Exome {
  public completed = false;

  constructor(public content: string) {
    super();
  }

  public toggle() {
    this.completed = !this.completed;
  }
}
```

We created `completed` property with default value `false`.

However `content` we want to define every time we create a new todo so we'll do that in constructor.

And we need some way to update `comleted` status so that will be handled in `toggle` action.

Next we need some store that handles list of todos:

```ts twoslash [todo-list.store.ts]
// @noErrors
import { Exome } from "exome";

export class TodoStore extends Exome {
  public completed = false;

  constructor(public content: string) {
    super();
  }

  public toggle() {
    this.completed = !this.completed;
  }
}
// ---cut---
import { Exome } from "exome";
import { TodoStore } from "./todo.store";

export class TodoListStore extends Exome {
  public todos: TodoStore[] = [];

  public addTodo(todo: TodoStore) {
    this.todos.push(todo);
  }
}
```

Here we have a store (`TodoListStore`) that contains other stores (`TodoStore`) in `todos` property. This is what exome was designed for.

Also we need a way to add new todo to the list, so that will be handled by `addTodo` action. This action expects already created `TodoStore` instance, but that is not a must, action can also create new `TodoStore` instance itself! I created it this way just to give extra control to dev creating a new todo item.

Ok so that's basically it, we created all that is needed for this app to work. Now lets create UI for this app.

I'll use react for this example, but you can chose any other integration.

```tsx twoslash [app.tsx]
// @noErrors
import { Exome } from "exome";

export class TodoStore extends Exome {
  public completed = false;

  constructor(public content: string) {
    super();
  }

  public toggle() {
    this.completed = !this.completed;
  }
}
import { Exome } from "exome";
import { TodoStore } from "./todo.store";

export class TodoListStore extends Exome {
  public todos: TodoStore[] = [];

  public addTodo(todo: TodoStore) {
    this.todos.push(todo);
  }
}
// ---cut---
import { getExomeId } from "exome";
import { useStore } from "exome/react";
import { TodoListStore } from "./todo-list.store";
import { TodoStore } from "./todo.store";

const todoListStore = new TodoListStore();

// Fill store with some demo values
todoListStore.addTodo(new TodoStore("Take out trash"));
todoListStore.addTodo(new TodoStore("Work out"));

function Todo({ todo }: { todo: TodoStore }) {
  const { completed, content, toggle } = useStore(todo);

  return (
    <label>
      <input type="checkbox" onChange={toggle} checked={completed} />
      {content}
    </label>
  );
}

export function TodoList() {
  const { todos, addTodo } = useStore(todoListStore);

  return (
    <ul>
      {todos.map((todo) => (
        <li key={getExomeId(todo)}>
          <Todo todo={todo} />
        </li>
      ))}
    </ul>
  );
}

```

<div className="live-code-preview">
<span>Live preview</span>
<LiveGuidesTodoReact />
</div>

Now we have fully functional todo store. You may notice that this app is not really complete as it's missing a way to add, delete and sort todos. This is covered in todo app tutorial.

## Testing

As for testing goes there are 2 things that can go wrong here:

### Snapshots

Usually running tests with snapshots, we get some kind of string representation of object we're testing. For example in jest, snapshot testing HTMLElements turns them into something similar to html tree, Objects into stringified json etc.

Exome store each have an id as symbol. Depending on configuration and environment, it may be displayed in snapshots.

Other thing that might go wrong in snapshots is testing cyclic stores as for example jest will throw error instead of making a snapshot.

For stores to work you can use `exome/jest` snapshot serializer. This works in `jest` and `vitest`. For other snapshot serializer implementations feel free to send in a PR.

For jest setup:
```json [jest.config.json]
{
  "snapshotSerializers": [
    "./node_modules/exome/jest/serializer.js"
  ]
}
```

For vitest currently it's a bit more of a setup:
```ts [vitest.setup.ts]
import * as exomeSnapshotSerializer from "exome/jest/serializer.js"

expect.addSnapshotSerializer({
  serialize(val, config, indentation, depth, refs, printer) {
    return exomeSnapshotSerializer.print(val, (val) =>
      printer(val, config, indentation, depth, refs)
    );
  },
  test: exomeSnapshotSerializer.test,
})
```

And that's it, now you should be covered with presenting store name, showing circular stores and getting rid of exome id symbol. It should look something like this:

```ts
TodoListStore {
  todos: [
    TodoStore {
      "content": "Take out thrash",
      "completed": false,
    },
  ],
}
```

### Mocking store

Generally it's not advised to mock store, but if you really need it, it can be done using [`GhostExome`](/api/ghost).

:::code-group

```ts twoslash [counter.store.test.ts]
// @noErrors
import { GhostExome } from "exome/ghost"
import { CounterStore } from "./counter.store.ts"

jest.mock("./counter.store.ts", () => ({
  CounterStore: class extends GhostExome {
    count: 0,
    increment: jest.fn(),
  },
}))

// ...
```

```ts twoslash [counter.store.ts]
import { Exome } from "exome"

export class CounterStore extends Exome {
  public count = 0

  public increment() {
    this.count += 1
  }
}
```

:::

Note that using it results in it pretending to be store. No change detection will occur on actions defined on this ghost store and no events will be triggered.

## Devtools

Exome has a companion browser extension [Exome Developer Tools](https://chromewebstore.google.com/detail/exome-developer-tools/pcanmpamoedhpfpbjajlkpicbikbnhdg) that sits inside browser devtools panel. It waits for connection from any website, but your website must start the connection. This can be used for connecting in dev environment but not in production. Or even connect in dev environment and in production define some kind of dev mode for your user and then connect to devtools for debugging in production.

Devtools contain detailed information about every store instance that is created and actions that are being triggered.

![](https://lh3.googleusercontent.com/Ycf-jws--Lb8wlXXqJyRIA8nmgfsODZoJ3mLl_9-G7mBibqZFZzqBj5pdWEl0v8nM4s9V_96xbkbEYB02hpwCPRagw=s1280-w1280-h800)

![](https://lh3.googleusercontent.com/ZrHePiQlxD5BCW00ENNJVpfvtyz7qHAZIhLsa1z_3bNSc4MR4Tk5t66zNHK5Oi28nrZ-wLSq63sg7MV5pVMwpC2-=s800-w800-h500)

Use `unstableExomeDevtools` to connect your app to devtools

```ts [Example] twoslash
// @noErrors
import { addMiddleware } from "exome"
import { unstableExomeDevtools } from "exome/devtools"

addMiddleware(
  unstableExomeDevtools({
    name: "App name",
  })
)
```

:::tip[NOTE]
Exome devtools is currently in alpha and may not be stable.
:::

## Custom integration

Every integration currently is based on `subscribe` function. For example this is react integration (it's a bit reduced for this example):

```ts twoslash [exome/react]
import { type Exome, subscribe } from "exome"
import { useLayoutEffect, useState } from "react"

export function useStore<T extends Exome>(store: T): Readonly<T> {
  const [, render] = useState(0)

  useLayoutEffect(
    () => subscribe(store, () => render((n) => n + 1)),
    [store],
  )

  return store
}
```

This is basically it, there's a `subscribe`, that takes in store instance and then updates component whenever change event is fired. After component unmounts subscription is canceled (unsubscribed).

Same recipe can be used for any other integration. Lets create some custom integration for our vanilla js counter app:

:::code-group

```ts twoslash [index.ts]
// @noErrors
import { subscribe } from "exome"
import { CounterStore, counterStore } from "./counter.store"

document.body.innerHTML = `
  <button id="count"></button>
`
const counterButton = document.getElementById("count")
counterButton.addEventListener("click", counterStore.increment)

const unsubscribe = subscribe(counterStore, update) // [!code hl]

function update(instance: CounterStore) { // [!code hl]
  counterButton.innerText = instance.count // [!code hl]
} // [!code hl]

// Run initial update if needed since update
// doesn't do it when first subscribed
update(counterStore)
```

```ts twoslash [counter.store.ts] filename="counter.store.ts"
// @noErrors
import { Exome } from "exome"

export class CounterStore extends Exome {
  public count = 0

  public increment() {
    this.count += 1
  }
}

export const counterStore = new CounterStore()
```

:::

<div className="live-code-preview">
<span>Live preview</span>
<LiveGuidesIntegrationReact />
</div>

For other type of integrations that cannot be covered only by update event you can use [`addMiddleware`](/api/exome#function-addmiddleware) and [`onAction`](/api/exome#function-onaction) functions.
